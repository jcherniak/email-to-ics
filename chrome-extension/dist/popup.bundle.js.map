{
  "version": 3,
  "sources": ["../popup.js"],
  "sourcesContent": ["// popup.js\n// DOM elements - Move these inside DOMContentLoaded\n// const contentDiv = document.getElementById('content'); \n// const statusDiv = document.getElementById('status');\n\n// Global state\nlet availableModels = [];\nlet selectedModel = null;\n// let pageScreenshot = null; // Managed within generateICS now\nlet baseUrl = 'https://new.justin-c.com/email-to-ics'; // Add default base URL\nlet targetUrl = `${baseUrl}/?display=email`;\nlet modelsEndpointUrl = `${baseUrl}/?get_models=1`;\nlet debugMode = false; // Add debug mode flag\nlet lastSubmitParams = null; // Store last submission details for retry\n\n// --- Initial state ---\n// Remove init() call from global scope\n// init();\n\nasync function init() { // Keep function definition for now, might be removed later\n    try {\n        // Fetch credentials, preferences, and base URL\n        const credentialsPromise = getStoredCredentials();\n        const preferencesPromise = getStoredPreferences();\n        const baseUrlPromise = getStoredBaseUrl();\n\n        // Wait for credentials and settings first\n        const [prefs, storedBaseUrl, credentials] = await Promise.all([\n            preferencesPromise,\n            baseUrlPromise,\n            credentialsPromise\n        ]);\n        \n        baseUrl = storedBaseUrl || 'https://new.justin-c.com/email-to-ics';\n        targetUrl = `${baseUrl}/?display=email`;\n        modelsEndpointUrl = `${baseUrl}/?get_models=1`;\n        debugMode = prefs.debugMode || false;\n        \n        if (!credentials || !storedBaseUrl) {\n            showCredentialsForm(); // Calls showCredentialsForm -> Original logic tried to set contentDiv.innerHTML\n        } else {\n            // Credentials exist, now fetch models\n            const modelsPromise = fetchAvailableModels();\n            try {\n                 const models = await modelsPromise;\n                \n                availableModels = models;\n                \n                selectedModel = prefs.defaultModel || (availableModels.length > 0 ? (availableModels.find(model => model.default) || availableModels[0]).id : null);\n                debugMode = prefs.debugMode || false;\n                \n                showForm(prefs); // Calls showForm -> Original logic tried to set contentDiv.innerHTML\n            } catch (error) {\n                console.error(\"Error initializing models:\", error); \n                availableModels = await modelsPromise.catch(() => []);\n                selectedModel = prefs.defaultModel || null;\n                showForm(prefs); // Still needs to show form on error\n            }\n        }\n    } catch (error) {\n        console.error(\"Init error:\", error);\n        showCredentialsForm(); // Fallback to login on general error\n    }\n}\n\n// --- Model Management Functions ---\nasync function fetchAvailableModels() {\n    try {\n        // Remove the redundant credential check - this function is now only called when logged in\n        /*\n        const credentials = await getStoredCredentials(); // Check credentials first\n        if (!credentials) {\n            console.warn(\"Cannot fetch models: Credentials not found during fetch.\");\n            return []; // Return empty array immediately if no credentials\n        }\n        */\n        const credentials = await getStoredCredentials(); // Still need credentials for the header\n        if (!credentials) {\n            console.error(\"No credentials available for fetching models\");\n            return [];\n        }\n        \n        const headers = {\n            'Authorization': 'Basic ' + credentials.encoded\n        };\n\n        // Add the flag to the models endpoint URL\n        const urlWithFlag = `${modelsEndpointUrl}&fromExtension=1`;\n\n        // Use dynamic modelsEndpointUrl and add auth header\n        const response = await fetch(urlWithFlag, { headers });\n        if (!response.ok) {\n            const errorText = await response.text(); // Log detailed error\n            console.error(`Fetch models response error (${response.status}):`, errorText);\n            throw new Error(`Failed to fetch models: ${response.status}`);\n        }\n        const data = await response.json();\n        console.log(\"Available models:\", data);\n        return data.models || [];\n    } catch (error) {\n        console.error(\"Error fetching models:\", error);\n        return [];\n    }\n}\n\n// --- Screenshot Capture ---\n\n// Helper function to be executed in the target tab's context\nfunction getPageDimensions() {\n    return {\n        scrollWidth: document.documentElement.scrollWidth,\n        scrollHeight: document.documentElement.scrollHeight,\n        innerWidth: window.innerWidth,\n        innerHeight: window.innerHeight,\n        originalZoom: document.body.style.zoom,\n        originalTransformOrigin: document.body.style.transformOrigin,\n        originalScrollX: window.scrollX,\n        originalScrollY: window.scrollY\n    };\n}\n\n// Helper function to apply zoom (runs in tab context)\nfunction applyZoomStyle(zoomFactor, originalZoom, originalTransformOrigin) {\n    document.body.style.zoom = zoomFactor;\n    document.body.style.transformOrigin = '0 0';\n    // Return originals in case needed, though we aim to just remove the style\n    return { originalZoom, originalTransformOrigin }; \n}\n\n// Helper function to remove zoom (runs in tab context)\nfunction removeZoomStyle(originalZoom, originalTransformOrigin) {\n    // Attempt to restore originals, or simply remove if they were empty\n    document.body.style.zoom = originalZoom || ''; \n    document.body.style.transformOrigin = originalTransformOrigin || '';\n}\n\n// Helper function to scroll (runs in tab context)\nfunction scrollToPosition(x, y) {\n    window.scrollTo(x, y);\n}\n\n// Updated screenshot logic using zoom and scroll\nasync function captureVisibleTabScreenshot() {\n    // Check if we're in an iframe\n    if (window.self !== window.top) {\n        // We're in an iframe, request screenshot from background\n        return new Promise((resolve) => {\n            chrome.runtime.sendMessage({ action: 'captureScreenshot' }, (response) => {\n                if (response && response.screenshot) {\n                    // Background returns base64 without data URL prefix\n                    resolve('data:image/jpeg;base64,' + response.screenshot);\n                } else {\n                    console.error('Screenshot request failed:', response?.error);\n                    resolve(null);\n                }\n            });\n        });\n    }\n    \n    // Original popup logic for when not in iframe\n    let originalState = {}; // Store original state (zoom, scroll)\n    const tab = await getActiveTab();\n    let dataUrl = null;\n\n    try {\n        // 1. Get dimensions and original state from the page\n        const [initialResult] = await chrome.scripting.executeScript({\n            target: { tabId: tab.id },\n            func: getPageDimensions\n        });\n        const state = initialResult.result;\n        originalState = { \n            zoom: state.originalZoom, \n            transformOrigin: state.originalTransformOrigin,\n            scrollX: state.originalScrollX,\n            scrollY: state.originalScrollY\n        }; \n\n        // 2. Scroll to top-left\n        await chrome.scripting.executeScript({\n            target: { tabId: tab.id },\n            func: scrollToPosition,\n            args: [0, 0]\n        });\n\n        // 3. Calculate zoom factor\n        const zoomX = state.innerWidth / state.scrollWidth;\n        const zoomY = state.innerHeight / state.scrollHeight;\n        const zoomFactor = Math.min(zoomX, zoomY, 1);\n\n        if (zoomFactor < 1) { \n            // 4. Apply zoom\n            await chrome.scripting.executeScript({\n                target: { tabId: tab.id },\n                func: applyZoomStyle,\n                args: [zoomFactor, originalState.zoom, originalState.transformOrigin]\n            });\n\n            // 5. Wait for rendering\n            await new Promise(resolve => setTimeout(resolve, 250)); \n        }\n\n        // 6. Capture screenshot\n        dataUrl = await chrome.tabs.captureVisibleTab(tab.windowId, {\n            format: 'jpeg',\n            quality: 90\n        });\n\n        if (!dataUrl) {\n             throw new Error(\"captureVisibleTab returned empty result after zoom/scroll.\");\n        }\n\n        console.log(\"Zoomed+Scrolled screenshot captured successfully\");\n        return dataUrl;\n\n    } catch (error) {\n        console.error(\"Zoomed+Scrolled screenshot capture error:\", error);\n        return null;\n    } finally {\n        // 7. Cleanup: Always try to restore zoom and scroll\n        if (Object.keys(originalState).length > 0) {\n             try {\n                // Remove zoom first\n                await chrome.scripting.executeScript({\n                    target: { tabId: tab.id }, \n                    func: removeZoomStyle,\n                    args: [originalState.zoom, originalState.transformOrigin]\n                });\n                // Then restore scroll\n                 await chrome.scripting.executeScript({\n                    target: { tabId: tab.id }, \n                    func: scrollToPosition,\n                    args: [originalState.scrollX, originalState.scrollY]\n                });\n            } catch (cleanupError) {\n                console.error(\"Error cleaning up zoom/scroll style:\", cleanupError);\n            }\n        }\n    }\n}\n\n// --- Credential Management Functions ---\nasync function checkCredentials() {\n    try {\n        const credentials = await getStoredCredentials();\n        const storedBaseUrl = await getStoredBaseUrl(); // Check base URL too\n        if (credentials && storedBaseUrl) {\n            showForm();\n        } else {\n            showCredentialsForm();\n        }\n    } catch (error) {\n        console.error(\"Error checking credentials:\", error);\n        showCredentialsForm();\n    }\n}\n\nasync function getStoredCredentials() {\n    return new Promise((resolve) => {\n        chrome.storage.sync.get(['username', 'password'], (result) => {\n            if (result.username && result.password) {\n                const credentials = btoa(`${result.username}:${result.password}`);\n                // Return object with username and encoded creds\n                resolve({ username: result.username, encoded: credentials }); \n            } else {\n                resolve(null);\n            }\n        });\n    });\n}\n\n// New helper to just get the username\nasync function getStoredUsername() {\n     return new Promise((resolve) => {\n        chrome.storage.sync.get(['username'], (result) => {\n            resolve(result.username || null);\n        });\n    });\n}\n\n// MODIFIED showCredentialsForm\nasync function showCredentialsForm(errorMessage = null) {\n    // This function now needs access to authSection and formSection\n    // It should primarily SHOW authSection and HIDE formSection\n    // The actual HTML content is already in popup.html\n    \n    // We might need to pass the DOM elements or get them here if needed,\n    // but the primary logic is handled by checkAuthenticationAndFetchConfig\n    // inside DOMContentLoaded now.\n    // This function might become redundant or simplified.\n    console.warn(\"showCredentialsForm called - logic likely moved to checkAuthenticationAndFetchConfig\");\n    // If called directly, ensure visibility is set correctly\n    const authSection = document.getElementById('auth-section');\n    const formSection = document.getElementById('form-section');\n    if (authSection) authSection.style.display = 'block';\n    if (formSection) formSection.style.display = 'none';\n\n    // Maybe display the error message somewhere?\n    if (errorMessage) {\n        const statusDiv = document.getElementById('status'); // Assuming statusDiv is accessible\n        if (statusDiv) {\n            statusDiv.textContent = errorMessage;\n            statusDiv.className = 'status-error';\n            statusDiv.style.display = 'block';\n        }\n    }\n}\n\nasync function saveCredentials(event) {\n    // ... (existing code, BUT the final call should be to the new init logic)\n    // Instead of init(), call checkAuthenticationAndFetchConfig if it's defined globally\n    // OR rely on the event listener setup within DOMContentLoaded\n}\n\n// --- Preferences Management ---\nasync function getStoredPreferences() {\n    return new Promise((resolve) => {\n        // Include debugMode in retrieval\n        chrome.storage.sync.get(['takeScreenshots', 'defaultModel', 'debugMode'], (result) => {\n            resolve({\n                takeScreenshots: result.takeScreenshots !== false, // Default to true if not set\n                defaultModel: result.defaultModel || null,\n                debugMode: result.debugMode || false // Default to false\n            });\n        });\n    });\n}\n\nfunction savePreferences(takeScreenshots, model, currentDebugMode) {\n    // Include debugMode in saving\n    debugMode = currentDebugMode; // Update global state\n    chrome.storage.sync.set({\n        takeScreenshots: takeScreenshots,\n        defaultModel: model,\n        debugMode: currentDebugMode\n    });\n    \n    // Also notify background script (if needed, though background doesn't use debug mode currently)\n    chrome.runtime.sendMessage({\n        action: 'savePreferences',\n        takeScreenshots: takeScreenshots,\n        defaultModel: model\n    });\n}\n\n// --- Main Form Functions ---\n// MODIFIED showForm\nfunction showForm(preferences = {}) {\n     // This function also becomes simpler. It mainly ensures\n     // formSection is visible and authSection is hidden.\n     // Populating the form fields (like model dropdown) still needs doing.\n    console.warn(\"showForm called - logic likely moved to checkAuthenticationAndFetchConfig\");\n    const authSection = document.getElementById('auth-section');\n    const formSection = document.getElementById('form-section');\n    if (authSection) authSection.style.display = 'none';\n    if (formSection) formSection.style.display = 'block';\n\n    // Populate models etc. should happen within checkAuthenticationAndFetchConfig\n}\n\n// MODIFIED showStatus\nfunction showStatus(type, messageHtml) {\n    // This function needs access to statusDiv\n    // It might be better defined *inside* DOMContentLoaded\n    console.warn(\"Global showStatus called\");\n    const statusDiv = document.getElementById('status');\n    if (!statusDiv) return;\n\n    statusDiv.innerHTML = messageHtml;\n    statusDiv.className = type; \n    // contentDiv.style.display = 'none'; // Cannot access contentDiv\n    const formSection = document.getElementById('form-section');\n    if (formSection) formSection.style.display = 'none';\n\n    // ... (rest of the showStatus logic for retry button etc.)\n}\n\n// --- Helper Functions ---\nasync function getActiveTab() {\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (tabs && tabs.length > 0) {\n        return tabs[0];\n    } else {\n        throw new Error(\"Could not get active tab.\");\n    }\n}\n\nasync function getPageContent(tabId) {\n    try {\n        const results = await chrome.scripting.executeScript({\n            target: { tabId: tabId },\n            func: () => ({\n                url: window.location.href,\n                html: document.documentElement.outerHTML\n            })\n        });\n        if (results && results[0] && results[0].result) {\n            return results[0].result;\n        } else {\n            console.error(\"Script execution failed or returned no result.\", results);\n            throw new Error(\"Could not get page content.\");\n        }\n    } catch (error) {\n        console.error(\"Error executing script:\", error);\n        if (chrome.runtime.lastError) {\n            console.error(\"Chrome runtime error:\", chrome.runtime.lastError.message);\n            throw new Error(`Failed to get page content: ${chrome.runtime.lastError.message}`);\n        }\n        throw error;\n    }\n}\n\n// --- Event Handlers ---\n\n// MODIFIED handleSubmit - logic moved to generateICS inside DOMContentLoaded\nasync function handleSubmit(event) {\n   console.error(\"Global handleSubmit called - should not happen\");\n}\n\n// MODIFIED executeSubmit - logic moved to generateICS inside DOMContentLoaded\nasync function executeSubmit(params) {\n   console.error(\"Global executeSubmit called - should not happen\");\n}\n\n// MODIFIED handleRetry - logic moved to event listener inside DOMContentLoaded\nasync function handleRetry() {\n    console.error(\"Global handleRetry called - should not happen\");\n}\n\n// MODIFIED getStoredBaseUrl - Keep\nasync function getStoredBaseUrl() {\n    return new Promise((resolve) => {\n        chrome.storage.sync.get(['baseUrl'], (result) => {\n            resolve(result.baseUrl || null);\n        });\n    });\n}\n\n// MODIFIED logout - Keep, but simplify\nasync function logout() {\n    // ... (clear storage) ...\n    // After clearing storage, just call the main init function from DOMContentLoaded\n    // This assumes checkAuthenticationAndFetchConfig handles the UI update\n    console.log(\"Logout called - relying on DOMContentLoaded handler to refresh UI\");\n    // Trigger the main check again\n    if (typeof checkAuthenticationAndFetchConfig === 'function') {\n         checkAuthenticationAndFetchConfig(); \n    } else {\n        // Fallback: reload the popup? Requires permission.\n        // window.location.reload(); \n        console.error(\"Cannot re-trigger auth check after logout.\");\n    }\n}\n\n// --- NEW Consolidated DOMContentLoaded Listener ---\n// The previous block starting with document.addEventListener should be the *only* one.\n// Remove the old code above this point or comment it out entirely.\n\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Check if we're running in an iframe\n    const isInIframe = window.self !== window.top;\n    \n    // Listen for messages from the parent window (if in iframe)\n    if (isInIframe) {\n        window.addEventListener('message', (event) => {\n            if (event.data.type === 'INIT_FROM_CONTENT') {\n                // Pre-fill URL from parent page\n                const urlInput = document.getElementById('url');\n                if (urlInput && event.data.data.url) {\n                    urlInput.value = event.data.data.url;\n                }\n            }\n        });\n    }\n    \n    // Add a manual handler for the collapse functionality\n    document.querySelector('[data-bs-toggle=\"collapse\"]').addEventListener('click', function() {\n        // Toggle the collapse\n        const targetId = this.getAttribute('data-bs-target');\n        const targetElement = document.querySelector(targetId);\n        \n        // Toggle the aria-expanded attribute\n        const isCurrentlyExpanded = this.getAttribute('aria-expanded') === 'true';\n        this.setAttribute('aria-expanded', !isCurrentlyExpanded);\n        \n        // Toggle the collapse element\n        if (targetElement) {\n            targetElement.classList.toggle('show');\n        }\n    });\n    \n    // Define ALL DOM element constants here\n    const statusDiv = document.getElementById('status');\n    const reviewStatusDiv = document.getElementById('review-status');\n    const urlInput = document.getElementById('url');\n    const convertButton = document.getElementById('convert-button');\n    // const screenshotButton = document.getElementById('screenshot-button'); // Removed\n    const instructionsInput = document.getElementById('instructions');\n    const modelSelect = document.getElementById('model-select');\n    // const modelDescriptionText = document.getElementById('model-description-text'); // Removed\n    const refreshModelsButton = document.getElementById('refresh-models');\n    const authSection = document.getElementById('auth-section');\n    const formSection = document.getElementById('form-section');\n    const openServerPageButton = document.getElementById('open-server-page');\n    const tentativeToggle = document.getElementById('tentative-toggle');\n    const multidayToggle = document.getElementById('multiday-toggle');\n    const reviewRadioGroup = document.querySelectorAll('input[name=\"review-option\"]');\n    const reviewSection = document.getElementById('review-section');\n    const reviewContent = document.getElementById('review-content');\n    const reviewRecipient = document.getElementById('review-recipient');\n    const reviewSubject = document.getElementById('review-subject'); // Get the new subject element\n    const sendButton = document.getElementById('send-button');\n    const rejectButton = document.getElementById('reject-button');\n\n    // --- NEW elements for processing view ---\n    const processingView = document.getElementById('processingView');\n    const requestData = document.getElementById('requestData');\n    const statusMessage = document.getElementById('statusMessage');\n    const responseData = document.getElementById('responseData');\n    const backToFormButton = document.getElementById('backToFormButton');\n    // --------------------------------------\n\n    // Define global state needed within this scope\n    let reviewData = null;\n    let serverUrl = ''; \n    let isAuthenticated = false;\n    let localAvailableModels = []; // Use a name different from global scope if needed\n    let serverDefaultModelId = null;\n    let currentTabId = null;\n\n    // Tab State Manager\n    class TabStateManager {\n        constructor() {\n            this.tabId = null;\n            this.stateKey = null;\n        }\n        \n        async initialize() {\n            try {\n                const [tab] = await chrome.tabs.query({active: true, currentWindow: true});\n                this.tabId = tab.id;\n                this.stateKey = `tab_${this.tabId}_state`;\n                currentTabId = this.tabId;\n                \n                // Restore state for current tab\n                await this.restoreState();\n                \n                // Save state when popup closes\n                window.addEventListener('beforeunload', () => this.saveState());\n            } catch (error) {\n                console.error('Error initializing tab state manager:', error);\n            }\n        }\n        \n        async saveState() {\n            if (!this.tabId) return;\n            \n            const state = {\n                formData: {\n                    url: urlInput?.value || '',\n                    instructions: instructionsInput?.value || '',\n                    model: modelSelect?.value || '',\n                    tentative: tentativeToggle?.checked || false,\n                    multiday: multidayToggle?.checked || false,\n                    reviewOption: document.querySelector('input[name=\"review-option\"]:checked')?.value || 'direct'\n                },\n                processingState: {\n                    isProcessing: processingView?.style.display === 'block',\n                    hasResults: responseData?.textContent || ''\n                },\n                timestamp: Date.now()\n            };\n            \n            try {\n                await chrome.storage.local.set({[this.stateKey]: state});\n                console.log('Saved state for tab', this.tabId);\n            } catch (error) {\n                console.error('Error saving tab state:', error);\n            }\n        }\n        \n        async restoreState() {\n            if (!this.tabId) return;\n            \n            try {\n                const result = await chrome.storage.local.get([this.stateKey]);\n                const state = result[this.stateKey];\n                \n                if (state && (Date.now() - state.timestamp) < 3600000) { // 1 hour\n                    const form = state.formData;\n                    if (form.url && urlInput) urlInput.value = form.url;\n                    if (form.instructions && instructionsInput) instructionsInput.value = form.instructions;\n                    if (form.model && modelSelect) modelSelect.value = form.model;\n                    if (tentativeToggle) tentativeToggle.checked = form.tentative;\n                    if (multidayToggle) multidayToggle.checked = form.multiday;\n                    if (form.reviewOption) {\n                        const radio = document.querySelector(`input[name=\"review-option\"][value=\"${form.reviewOption}\"]`);\n                        if (radio) radio.checked = true;\n                    }\n                    \n                    console.log('Restored state for tab', this.tabId);\n                }\n            } catch (error) {\n                console.error('Error restoring tab state:', error);\n            }\n        }\n        \n        async cleanup() {\n            try {\n                const allItems = await chrome.storage.local.get(null);\n                const now = Date.now();\n                const keysToRemove = [];\n                \n                for (const key in allItems) {\n                    if (key.startsWith('tab_') && key.endsWith('_state')) {\n                        const state = allItems[key];\n                        if (state && now - state.timestamp > 86400000) { // 24 hours\n                            keysToRemove.push(key);\n                        }\n                    }\n                }\n                \n                if (keysToRemove.length > 0) {\n                    await chrome.storage.local.remove(keysToRemove);\n                    console.log('Cleaned up', keysToRemove.length, 'old tab states');\n                }\n            } catch (error) {\n                console.error('Error cleaning up tab states:', error);\n            }\n        }\n    }\n    \n    // Initialize tab state manager\n    const tabStateManager = new TabStateManager();\n\n    // --- Utility Functions defined within this scope ---\n    // Screenshot helpers\n    function getPageDimensions() {\n        return {\n            scrollWidth: document.documentElement.scrollWidth,\n            scrollHeight: document.documentElement.scrollHeight,\n            innerWidth: window.innerWidth,\n            innerHeight: window.innerHeight,\n            originalZoom: document.body.style.zoom,\n            originalTransformOrigin: document.body.style.transformOrigin,\n            originalScrollX: window.scrollX,\n            originalScrollY: window.scrollY\n        };\n    }\n    function applyZoomStyle(zoomFactor, originalZoom, originalTransformOrigin) {\n        document.body.style.zoom = zoomFactor;\n        document.body.style.transformOrigin = '0 0';\n        return { originalZoom, originalTransformOrigin }; \n    }\n    function removeZoomStyle(originalZoom, originalTransformOrigin) {\n        document.body.style.zoom = originalZoom || ''; \n        document.body.style.transformOrigin = originalTransformOrigin || '';\n    }\n    function scrollToPosition(x, y) {\n        window.scrollTo(x, y);\n    }\n    // Main screenshot function\n    async function captureVisibleTabScreenshot() {\n        // Check if we're in an iframe\n        if (window.self !== window.top) {\n            // We're in an iframe, request screenshot from background\n            return new Promise((resolve) => {\n                chrome.runtime.sendMessage({ action: 'captureScreenshot' }, (response) => {\n                    if (response && response.screenshot) {\n                        // Background returns base64 without data URL prefix\n                        resolve('data:image/jpeg;base64,' + response.screenshot);\n                    } else {\n                        console.error('Screenshot request failed:', response?.error);\n                        resolve(null);\n                    }\n                });\n            });\n        }\n        \n        // Original popup logic for when not in iframe\n        let originalState = {}; \n        const tab = await getActiveTab(); // Needs getActiveTab defined in scope too\n        let dataUrl = null;\n\n        try {\n            const [initialResult] = await chrome.scripting.executeScript({\n                target: { tabId: tab.id },\n                func: getPageDimensions\n            });\n            const state = initialResult.result;\n            originalState = { \n                zoom: state.originalZoom, \n                transformOrigin: state.originalTransformOrigin,\n                scrollX: state.originalScrollX,\n                scrollY: state.originalScrollY\n            }; \n\n            await chrome.scripting.executeScript({\n                target: { tabId: tab.id },\n                func: scrollToPosition,\n                args: [0, 0]\n            });\n\n            const zoomX = state.innerWidth / state.scrollWidth;\n            const zoomY = state.innerHeight / state.scrollHeight;\n            const zoomFactor = Math.min(zoomX, zoomY, 1);\n\n            if (zoomFactor < 1) { \n                await chrome.scripting.executeScript({\n                    target: { tabId: tab.id },\n                    func: applyZoomStyle,\n                    args: [zoomFactor, originalState.zoom, originalState.transformOrigin]\n                });\n                await new Promise(resolve => setTimeout(resolve, 250)); \n            }\n\n            dataUrl = await chrome.tabs.captureVisibleTab(tab.windowId, {\n                format: 'jpeg',\n                quality: 90\n            });\n\n            if (!dataUrl) {\n                 throw new Error(\"captureVisibleTab returned empty result after zoom/scroll.\");\n            }\n            console.log(\"Zoomed+Scrolled screenshot captured successfully\");\n            return dataUrl;\n\n        } catch (error) {\n            console.error(\"Zoomed+Scrolled screenshot capture error:\", error);\n            return null;\n        } finally {\n            if (Object.keys(originalState).length > 0) {\n                 try {\n                    await chrome.scripting.executeScript({\n                        target: { tabId: tab.id }, \n                        func: removeZoomStyle,\n                        args: [originalState.zoom, originalState.transformOrigin]\n                    });\n                     await chrome.scripting.executeScript({\n                        target: { tabId: tab.id }, \n                        func: scrollToPosition,\n                        args: [originalState.scrollX, originalState.scrollY]\n                    });\n                } catch (cleanupError) {\n                    console.error(\"Error cleaning up zoom/scroll style:\", cleanupError);\n                }\n            }\n        }\n    }\n\n    // Helper function to get active tab (needed by screenshot)\n    async function getActiveTab() {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (tabs && tabs.length > 0) {\n            return tabs[0];\n        } else {\n            throw new Error(\"Could not get active tab.\");\n        }\n    }\n\n    // Status and UI helpers\n    function showStatus(message, type = 'loading', isError = false) { // Added isError flag\n        if (!statusDiv) return;\n        statusDiv.textContent = message;\n        statusDiv.className = `status-${type}`;\n        statusDiv.style.display = 'block';\n        // Adjust body class for errors if needed\n        if (isError) { \n             document.body.classList.add('error-state');\n        } else {\n             document.body.classList.remove('error-state');\n        }\n    }\n\n    function showReviewStatus(message, type = 'loading') {\n         if (!reviewStatusDiv) return;\n        reviewStatusDiv.textContent = message;\n        reviewStatusDiv.className = `status-${type}`;\n        reviewStatusDiv.style.display = 'block';\n    }\n    \n    // Define hideStatus, hideReviewStatus, disableForm, disableReviewButtons\n    function hideStatus() {\n        if (!statusDiv) return;\n        statusDiv.style.display = 'none';\n        statusDiv.textContent = '';\n        document.body.classList.remove('error-state'); // Also remove error state class\n    }\n\n    function hideReviewStatus() {\n        if (!reviewStatusDiv) return;\n        reviewStatusDiv.style.display = 'none';\n        reviewStatusDiv.textContent = '';\n    }\n\n    function disableForm(disable = true) {\n        urlInput.disabled = disable;\n        instructionsInput.disabled = disable;\n        convertButton.disabled = disable;\n        modelSelect.disabled = disable;\n        refreshModelsButton.disabled = disable;\n        tentativeToggle.disabled = disable;\n        reviewRadioGroup.forEach(radio => radio.disabled = disable);\n    }\n\n    function disableReviewButtons(disable = true) {\n        sendButton.disabled = disable;\n        rejectButton.disabled = disable;\n    }\n\n    // --- Core Logic defined within this scope ---\n    // Move checkAuthenticationAndFetchConfig, loadModels, populateModelDropdown here\n    // Ensure they use localAvailableModels, serverUrl, etc.\n\n    // Definition for loadModels\n    async function loadModels(forceRefresh = false) {\n        if (!isAuthenticated) {\n            console.log(\"loadModels: Not authenticated, skipping.\");\n        return;\n    }\n\n        // Basic caching check (adjust if more sophisticated caching needed)\n        if (!forceRefresh && localAvailableModels.length > 0) {\n             console.log('loadModels: Using cached models.');\n             populateModelDropdown(); // Use local populate\n             return;\n         }\n\n        console.log(\"loadModels: Fetching models from server...\");\n        showStatus('Loading AI models...'); // Use local showStatus\n        if(modelSelect) modelSelect.disabled = true;\n        if(refreshModelsButton) refreshModelsButton.disabled = true;\n\n        try {\n            const response = await fetch(`${serverUrl}?get_models=true`, {\n                method: 'GET',\n                headers: { 'Accept': 'application/json' },\n                 credentials: 'include' // Send cookies\n            });\n\n             console.log(\"loadModels: Fetch response status:\", response.status);\n\n            if (!response.ok) {\n                 if (response.status === 401) {\n                     console.log(\"loadModels: Status 401 - Unauthorized during refresh\");\n                     isAuthenticated = false;\n                     if (authSection) authSection.style.display = 'block';\n                     if (formSection) formSection.style.display = 'none';\n                     hideStatus();\n                     return;\n                 }\n                 const errorText = await response.text();\n                 console.error(\"loadModels: Fetch failed:\", errorText);\n                 throw new Error(`Failed to fetch models: ${response.statusText}`);\n             }\n\n            const data = await response.json();\n             console.log(\"loadModels: Received data:\", data);\n\n            if (!data || !Array.isArray(data.models)) {\n                console.error(\"loadModels: Invalid model data received:\", data);\n                throw new Error('Invalid model data received from server.');\n            }\n\n            localAvailableModels = data.models; // Store in local scope variable\n            // Find the default model ID from the response\n            serverDefaultModelId = localAvailableModels.find(m => m.default)?.id || (localAvailableModels.length > 0 ? localAvailableModels[0].id : null);\n            console.log(\"loadModels: Server default model ID:\", serverDefaultModelId);\n\n            populateModelDropdown(); // Use local populate\n            hideStatus(); // Use local hideStatus\n\n        } catch (error) {\n            console.error('loadModels: Error loading models:', error);\n            showStatus(`Error loading models: ${error.message}`, 'error', true); // Use local showStatus\n            if(modelSelect) modelSelect.innerHTML = '<option value=\"\">Error loading</option>';\n        } finally {\n            if(modelSelect) modelSelect.disabled = false;\n            if(refreshModelsButton) refreshModelsButton.disabled = false;\n            console.log(\"loadModels: Finished.\");\n        }\n    }\n\n    // Definition for populateModelDropdown\n    function populateModelDropdown() {\n        if (!modelSelect) return;\n        modelSelect.innerHTML = ''; // Clear existing options\n        console.log(\"populateModelDropdown: Populating with models:\", localAvailableModels);\n\n        if (localAvailableModels.length === 0) {\n            modelSelect.innerHTML = '<option value=\"\">No models available</option>';\n            // if(modelDescriptionText) modelDescriptionText.textContent = 'Could not load models from the server.'; // Removed\n            return;\n        }\n\n        localAvailableModels.forEach(model => {\n            const option = document.createElement('option');\n            option.value = model.id;\n            option.textContent = model.name + (model.vision_capable ? ' (Vision)' : '');\n            // Select based on the serverDefaultModelId determined in loadModels\n            option.selected = (model.id === serverDefaultModelId);\n            modelSelect.appendChild(option);\n        });\n\n        // Trigger change event AFTER options are added\n        // modelSelect.dispatchEvent(new Event('change')); // No longer needed as description is gone\n         console.log(\"populateModelDropdown: Finished.\");\n    }\n\n    async function checkAuthenticationAndFetchConfig() {\n        console.log(\"checkAuthenticationAndFetchConfig: Starting\"); \n        try {\n            // 1. Get Base URL from storage\n            console.log(\"checkAuthenticationAndFetchConfig: Getting baseUrl from storage\");\n            const data = await new Promise((resolve) => {\n                chrome.storage.sync.get(['baseUrl'], resolve);\n            });\n            serverUrl = data.baseUrl;\n\n            // Fetch config to get server URL - REMOVED\n            /* \n            console.log(\"checkAuthenticationAndFetchConfig: Fetching config.json\");\n            const configResponse = await fetch(chrome.runtime.getURL('config.json'));\n            if (!configResponse.ok) throw new Error('Failed to load config.json');\n            const config = await configResponse.json();\n            serverUrl = config.serverUrl;\n            */\n           \n            console.log(\"checkAuthenticationAndFetchConfig: Got serverUrl from storage:\", serverUrl);\n\n            if (!serverUrl) {\n                // If no URL stored, treat as unauthorized/needs configuration\n                console.log(\"checkAuthenticationAndFetchConfig: No serverUrl in storage - showing auth section.\");\n                isAuthenticated = false;\n                if (authSection) authSection.style.display = 'block';\n                if (formSection) formSection.style.display = 'none';\n                hideStatus(); \n                return; // Stop further execution\n            }\n\n            // Ensure trailing slash for consistency\n            if (!serverUrl.endsWith('/')) {\n                serverUrl += '/';\n            }\n\n            // 2. Check auth by trying to fetch models\n            showStatus('Checking authentication...'); \n            console.log(\"checkAuthenticationAndFetchConfig: Fetching models for auth check:\", `${serverUrl}?get_models=true`);\n            const modelsResponse = await fetch(`${serverUrl}?get_models=true`, {\n                method: 'GET',\n            headers: {\n                    'Accept': 'application/json'\n                },\n                credentials: 'include'\n            });\n\n            console.log(\"checkAuthenticationAndFetchConfig: Auth check response status:\", modelsResponse.status);\n\n            if (modelsResponse.status === 401) {\n                // Unauthorized\n                console.log(\"checkAuthenticationAndFetchConfig: Status 401 - Unauthorized\");\n                isAuthenticated = false;\n                if (authSection) authSection.style.display = 'block';\n                if (formSection) formSection.style.display = 'none';\n                hideStatus(); \n                console.log(\"checkAuthenticationAndFetchConfig: Showing auth section.\");\n            } else if (!modelsResponse.ok) {\n                // Other server error\n                console.error(\"checkAuthenticationAndFetchConfig: Auth check fetch failed (not OK)\");\n                throw new Error(`Server error checking auth: ${modelsResponse.statusText}`);\n            } else {\n                // Authorized\n                 console.log(\"checkAuthenticationAndFetchConfig: Status OK - Authorized\");\n                isAuthenticated = true;\n                if (authSection) authSection.style.display = 'none';\n                if (formSection) formSection.style.display = 'block';\n                hideStatus(); \n                console.log(\"checkAuthenticationAndFetchConfig: Showing form section, loading models...\");\n                await loadModels(); \n                // Populate URL field with the current tab's URL\n                chrome.tabs.query({ active: true, currentWindow: true }, function(tabs) {\n                    if (tabs[0] && tabs[0].url && (tabs[0].url.startsWith('http:') || tabs[0].url.startsWith('https:'))) {\n                        if (urlInput) urlInput.value = tabs[0].url;\n                         console.log(\"checkAuthenticationAndFetchConfig: Populated URL field.\");\n                    }\n                });\n            }\n\n        } catch (error) {\n            console.error('checkAuthenticationAndFetchConfig: Error:', error);\n            showStatus(`Error: ${error.message}`, 'error', true); \n            // Ensure both sections are hidden on error\n            if (authSection) authSection.style.display = 'none';\n            if (formSection) formSection.style.display = 'none';\n            console.log(\"checkAuthenticationAndFetchConfig: Hiding sections due to error.\");\n        }\n    }\n\n    // --- NEW: Function to check and apply context menu instructions ---\n    async function applyContextMenuInstructions() {\n        try {\n            const data = await new Promise((resolve) => {\n                chrome.storage.local.get(['contextMenuInstructions'], resolve);\n            });\n\n            if (data && data.contextMenuInstructions) {\n                console.log(\"Applying context menu instructions:\", data.contextMenuInstructions);\n                if (instructionsInput) {\n                    instructionsInput.value = data.contextMenuInstructions;\n                }\n                // Clear the stored value so it's not reused\n                chrome.storage.local.remove('contextMenuInstructions', () => {\n                    if (chrome.runtime.lastError) {\n                        console.error(\"Error removing context menu instructions:\", chrome.runtime.lastError);\n                    }\n                });\n            }\n        } catch (error) {\n            console.error(\"Error applying context menu instructions:\", error);\n        }\n    }\n    // ----------------------------------------------------------------\n\n    // --- NEW: Refactored/Modified generateICS ---\n    async function generateICS() {\n        if (!isAuthenticated) {\n            showStatus('Not authenticated.', 'error', true); // Still use showStatus for initial auth error\n            return;\n        }\n\n        let showingReview = false; // <--- DECLARE showingReview here\n\n        const urlValue = urlInput.value.trim();\n        const instructionsValue = instructionsInput.value.trim();\n        const selectedModelValue = modelSelect.value;\n        const isTentativeValue = tentativeToggle.checked;\n        const isMultidayValue = multidayToggle.checked;\n        const reviewOptionValue = document.querySelector('input[name=\\\"review-option\\\"]:checked')?.value || 'direct';\n\n        // Prepare request details text\n        let requestDetailsText = `URL: ${urlValue || '(Using current tab)'}\\n`;\n        requestDetailsText += `Instructions: ${instructionsValue || '(None)'}\\n`;\n        requestDetailsText += `Model: ${selectedModelValue || '(Default)'}\\n`;\n        requestDetailsText += `Tentative: ${isTentativeValue}\\n`;\n        requestDetailsText += `Multi-day: ${isMultidayValue}\\n`;\n        requestDetailsText += `Review Option: ${reviewOptionValue}\\n`;\n        requestData.textContent = requestDetailsText;\n\n        // Switch view - keep form visible during processing\n        hideStatus(); // Hide main status div if it was shown\n        hideReviewStatus();\n        reviewSection.style.display = 'none';\n        processingView.style.display = 'block';\n        // Keep formSection visible below the processing view\n        statusMessage.textContent = 'Processing...';\n        statusMessage.className = 'status-loading';\n        responseData.textContent = '';\n        disableForm(); // Disable original form fields\n        backToFormButton.disabled = true; // Disable back button during processing\n\n        let htmlContent = '';\n        let screenshotViewportData = null;\n        let screenshotZoomedData = null;\n\n        try {\n            // 1. Get current page HTML (unchanged)\n            const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n            if (!tabs || tabs.length === 0) throw new Error(\"Could not get active tab.\");\n            const tabId = tabs[0].id;\n            const currentTabUrl = tabs[0].url;\n            const results = await chrome.scripting.executeScript({\n                target: { tabId: tabId },\n                func: () => document.documentElement.outerHTML\n            });\n            if (results && results[0] && results[0].result) htmlContent = results[0].result;\n            else console.warn(\"Could not get HTML content.\");\n\n            // 2. Capture screenshots (unchanged, update status message)\n            statusMessage.textContent = 'Capturing screenshots...';\n            try {\n                screenshotViewportData = await chrome.tabs.captureVisibleTab(null, { format: 'jpeg', quality: 80 });\n                if (screenshotViewportData && screenshotViewportData.startsWith('data:image/jpeg;base64,')) {\n                    screenshotViewportData = screenshotViewportData.substring('data:image/jpeg;base64,'.length);\n                } else screenshotViewportData = null;\n            } catch (vpError) { console.error('Viewport screenshot failed:', vpError); screenshotViewportData = null; }\n\n            try {\n                const zoomedDataUrl = await captureVisibleTabScreenshot();\n                if (zoomedDataUrl && zoomedDataUrl.startsWith('data:image/jpeg;base64,')) {\n                    screenshotZoomedData = zoomedDataUrl.substring('data:image/jpeg;base64,'.length);\n                } else screenshotZoomedData = null;\n            } catch (zoomError) { console.error('Zoomed screenshot failed:', zoomError); screenshotZoomedData = null; }\n\n            // 3. Prepare data for server\n            statusMessage.textContent = 'Sending to server...';\n            const formData = new URLSearchParams();\n            formData.append('url', urlValue || currentTabUrl); \n            formData.append('html', htmlContent);\n            formData.append('instructions', instructionsValue);\n            formData.append('model', selectedModelValue);\n            formData.append('tentative', isTentativeValue ? '1' : '0');\n            formData.append('multiday', isMultidayValue ? '1' : '0');\n            formData.append('review', reviewOptionValue === 'review' ? '1' : '0');\n            formData.append('fromExtension', 'true');\n            formData.append('display', 'email');\n            if (screenshotViewportData) formData.append('screenshot_viewport', screenshotViewportData);\n            if (screenshotZoomedData) formData.append('screenshot_zoomed', screenshotZoomedData);\n\n            // 4. Send data to server (modified response handling)\n            let resultJson = null;\n            const response = await fetch(serverUrl, {\n                method: 'POST',\n                headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n                body: formData,\n                credentials: 'include'\n            });\n            \n            const responseText = await response.text(); // Get raw text response\n\n            console.log(\"RAW RESPONSE TEXT (first 100 chars):\", responseText.substring(0, 100));\n            // Check if it looks like JSON with needsReview: true\n            if (responseText.includes('\\\"needsReview\\\":true')) {\n                console.log(\"RAW TEXT CONTAINS needsReview:true!\");\n            }\n            \n            if (!response.ok) {\n                // Show error in processing view\n                statusMessage.textContent = `Error: ${response.status} ${response.statusText}`;\n                statusMessage.className = 'status-error';\n                console.error(\"Server returned error:\", response.status, responseText);\n                responseData.textContent = responseText; // Show raw error response\n            } else {\n                // Try parsing successful response as JSON\n                try {\n                    resultJson = JSON.parse(responseText);\n                    console.log(\"PARSED JSON RESPONSE:\", resultJson);\n                    console.log(\"needsReview:\", resultJson.needsReview);\n                    console.log(\"confirmationToken:\", resultJson.confirmationToken);\n                    console.log(\"icsContent length:\", resultJson.icsContent ? resultJson.icsContent.length : 'missing');\n \n                    if (resultJson.needsReview) {\n                        // Review is needed according to the server\n                        if (resultJson.confirmationToken && resultJson.icsContent) {\n                            console.log(\"SHOWING REVIEW SECTION - conditions met\");\n                            // All required data for review is present\n                            showReviewSection(resultJson);\n                            showingReview = true;\n                        } else {\n                            console.log(\"NOT SHOWING REVIEW - missing required data\");\n                            console.log(\"confirmationToken present:\", !!resultJson.confirmationToken);\n                            console.log(\"icsContent present:\", !!resultJson.icsContent);\n                            // Review needed, but data is missing! Show error in processing view.\n                            console.error(\"Review needed, but missing confirmationToken or icsContent from server:\", resultJson);\n                            statusMessage.textContent = 'Error: Review data missing from server.';\n                        }\n                    } else {\n                         // Show PROCESSING view - Success (Sent Directly)\n                        statusMessage.textContent = 'Success (Sent Directly)';\n                        statusMessage.className = 'status-success';\n                        \n                        // Create a cleaner success response structure\n                        let responseHTML = '';\n                        \n                        // Add the success message\n                        if (resultJson.message) {\n                            responseHTML += `<div class=\"success-message\">${resultJson.message}</div>`;\n                        }\n                        \n                        // Add the event details directly, not in another card\n                        if (resultJson.icsContent) {\n                            // Extract just the essential details \n                            responseHTML += parseAndDisplayIcs(resultJson.icsContent);\n                        } else {\n                            // Fallback for no ICS content\n                            responseHTML += `<pre class=\"plain-text\">${responseText}</pre>`;\n                        }\n                        \n                        // Set the HTML\n                        responseData.innerHTML = responseHTML;\n                        \n                        console.log(\"Success (Sent Directly), displayed details\");\n                        \n                        // Leave showingReview as false\n                    }\n                } catch (e) {\n                    // JSON parsing failed, show raw response in processing view\n                    console.warn(\"Could not parse JSON response, showing raw text.\", e);\n                    statusMessage.textContent = 'Success (Raw Response)';\n                    statusMessage.className = 'status-success';\n                    responseData.textContent = responseText;\n                    // Leave showingReview as false\n                }\n            }\n\n        } catch (error) {\n            // JS/Fetch error - Show PROCESSING view - Error\n            console.error('generateICS Error:', error);\n            statusMessage.textContent = `Error: ${error.message || 'Unknown error'}`;\n            statusMessage.className = 'status-error';\n            responseData.textContent = error.stack || ''; // Show stack trace in response for JS errors\n            // Leave showingReview as false\n        } finally {\n            // Only enable back button if processing view is shown\n            if (!showingReview && backToFormButton) {\n                backToFormButton.disabled = false;\n            }\n            // Do NOT re-enable the main form here regardless\n        }\n    }\n    // --------------------------------------------\n\n    async function sendReviewedICS() {\n        if (!reviewData || !reviewData.confirmationToken) {\n            showReviewStatus('Error: Missing confirmation data.', 'error');\n            return;\n        }\n\n        showReviewStatus('Sending confirmation...', 'loading');\n        disableReviewButtons();\n\n        try {\n            const formData = new URLSearchParams();\n            formData.append('confirmationToken', reviewData.confirmationToken);\n\n            const response = await fetch(`${serverUrl}?confirm=true`, { // Send to confirmation endpoint\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                },\n                body: formData,\n                credentials: 'include'\n            });\n\n            const resultText = await response.text(); // Get text response\n\n            if (!response.ok) {\n                let errorMsg = `Server error: ${response.status}`; \n                try { errorMsg += `: ${JSON.parse(resultText).error}`; } catch(e){} // Try to get JSON error\n                throw new Error(errorMsg);\n            }\n\n            // Success!\n            showReviewStatus('Email sent successfully!', 'success');\n            // Optionally hide review section after a delay or show a 'Done' button\n            setTimeout(() => {\n                hideReviewSection();\n            }, 2500); // Hide after 2.5 seconds\n\n        } catch (error) {\n            console.error('Error sending confirmation:', error);\n            showReviewStatus(`Error sending: ${error.message}`, 'error');\n            disableReviewButtons(false); // Re-enable buttons on error\n        }\n    }\n\n    // --- Event Listeners defined within this scope ---\n    convertButton?.addEventListener('click', generateICS);\n    refreshModelsButton?.addEventListener('click', () => loadModels(true));\n    openServerPageButton?.addEventListener('click', () => {\n        if (serverUrl) chrome.tabs.create({ url: serverUrl });\n    });\n    sendButton?.addEventListener('click', sendReviewedICS);\n    rejectButton?.addEventListener('click', hideReviewSection);\n    \n    // Add state saving listeners for form changes\n    urlInput?.addEventListener('input', () => tabStateManager.saveState());\n    instructionsInput?.addEventListener('input', () => tabStateManager.saveState());\n    modelSelect?.addEventListener('change', () => tabStateManager.saveState());\n    tentativeToggle?.addEventListener('change', () => tabStateManager.saveState());\n    multidayToggle?.addEventListener('change', () => tabStateManager.saveState());\n    reviewRadioGroup?.forEach(radio => {\n        radio.addEventListener('change', () => tabStateManager.saveState());\n    });\n\n    // --- NEW Back Button Listener ---\n    backToFormButton?.addEventListener('click', () => {\n        processingView.style.display = 'none';\n        formSection.style.display = 'block';\n        disableForm(false); // Re-enable the main form controls\n    });\n    // -------------------------------\n    \n    // --- NEW Keyboard Shortcut Listener ---\n    document.addEventListener('keydown', function(event) {\n        // Check if the active element is NOT a textarea or input to avoid interfering with typing\n        const activeElement = document.activeElement;\n        const isTypingArea = activeElement && (activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'INPUT');\n\n        if (event.key === 'Enter' && (event.ctrlKey || event.metaKey) && !isTypingArea) {\n            // Only trigger if form is visible and not currently processing\n            if (formSection.style.display !== 'none' && processingView.style.display === 'none') {\n                event.preventDefault();\n                convertButton?.click(); \n            }\n        }\n    });\n    // -----------------------------------\n\n    // --- Initialization ---\n    Promise.all([\n        checkAuthenticationAndFetchConfig(),\n        tabStateManager.initialize()\n    ]).then(() => {\n        // After auth check and basic UI setup, check for context menu instructions\n        applyContextMenuInstructions();\n        \n        // Start periodic cleanup\n        setInterval(() => tabStateManager.cleanup(), 3600000); // Every hour\n    });\n\n    function hideReviewSection() {\n        reviewSection.style.display = 'none';\n        formSection.style.display = 'block'; // Show the main form again\n        reviewData = null;\n        hideReviewStatus();\n        disableForm(false); // Re-enable main form controls\n    }\n\n    // --- Updated iCal Parser Helper (using ical.js) ---\n    function parseAndDisplayIcs(icsString) {\n        console.log(\"parseAndDisplayIcs (using ical.js) called - icsString length:\", icsString ? icsString.length : 'none');\n        if (!icsString) return '<p>No ICS data available.</p>';\n\n        try {\n            const jcalData = ICAL.parse(icsString);\n            const vcalendar = new ICAL.Component(jcalData);\n            const vevent = vcalendar.getFirstSubcomponent('vevent');\n\n            if (!vevent) {\n                throw new Error('Could not find VEVENT component in ICS data.');\n            }\n\n            const event = new ICAL.Event(vevent);\n\n            let html = '<dl class=\"ics-details\">';\n\n            // Helper to add property if it exists\n            const addProperty = (label, value) => {\n                if (value) {\n                    // Unescape common characters and handle escaped newlines for display\n                    const displayValue = String(value)\n                        .replace(/\\\\,/g, ',')\n                        .replace(/\\\\;/g, ';')\n                        .replace(/\\\\\\\\/g, '\\\\')\n                        .replace(/\\\\n/g, '<br>'); // Convert escaped newlines to HTML breaks\n                    html += `<dt>${label}:</dt><dd>${displayValue}</dd>`;\n                }\n            };\n\n            addProperty('Event', event.summary);\n            addProperty('Location', event.location);\n\n            // Format dates using toJSDate().toLocaleString() for better readability\n            const startDate = event.startDate;\n            const endDate = event.endDate;\n            if (startDate) {\n                try {\n                    addProperty('Start', startDate.toJSDate().toLocaleString());\n                } catch(dateError) {\n                    console.warn(\"Could not format start date:\", dateError);\n                    addProperty('Start', startDate.toString()); // Fallback to basic string\n                }\n            }\n            if (endDate) {\n                 try {\n                    addProperty('End', endDate.toJSDate().toLocaleString());\n                 } catch(dateError) {\n                    console.warn(\"Could not format end date:\", dateError);\n                    addProperty('End', endDate.toString()); // Fallback to basic string\n                }\n            }\n\n            addProperty('Description', event.description);\n\n            html += '</dl>';\n\n            // Add the raw ICS for debugging (collapsible)\n            html += '<details><summary>Raw ICS Data</summary><pre>';\n            // Escape HTML characters in the raw ICS string for safe display within <pre>\n            html += icsString.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n            html += '</pre></details>';\n\n            return html;\n\n        } catch (error) {\n            console.error(\"Error parsing/displaying ICS with ical.js:\", error);\n            // Fallback: still provide at least the raw data, escaping HTML chars\n            return `<p class=\"error\">Error displaying ICS: ${error.message}</p>\n                    <pre>${icsString.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;\n        }\n    }\n\n    // --- Updated showReviewSection ---\n    function showReviewSection(data) { // Expects parsed JSON data\n        console.log(\"showReviewSection called with data:\", data);\n        // Store necessary data for sending confirmation\n        reviewData = {\n            confirmationToken: data.confirmationToken,\n            recipientEmail: data.recipientEmail, // Keep for display\n            emailSubject: data.emailSubject,     // Keep for display\n            icsContent: data.icsContent           // Keep for display/debugging\n        };\n        console.log(\"reviewData set:\", reviewData);\n\n        reviewRecipient.textContent = data.recipientEmail || 'Unknown';\n        reviewSubject.textContent = data.emailSubject || 'No Subject'; // Populate subject\n        console.log(\"Review recipient/subject populated\");\n\n        // Parse and display the ICS content using the helper\n        console.log(\"About to parse ICS content using ical.js\");\n        reviewContent.innerHTML = parseAndDisplayIcs(data.icsContent || '');\n        console.log(\"ICS content parsed and set to innerHTML\");\n\n        formSection.style.display = 'none';\n        processingView.style.display = 'none'; // Hide processing view too\n        reviewSection.style.display = 'block';\n        console.log(\"Display set: formSection=none, processingView=none, reviewSection=block\");\n        hideStatus();\n        hideReviewStatus();\n        disableReviewButtons(false);\n        console.log(\"Review section display complete\");\n    }\n});\n// ... rest of the file ..."],
  "mappings": "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",
  "names": ["urlInput", "checkAuthenticationAndFetchConfig"]
}
